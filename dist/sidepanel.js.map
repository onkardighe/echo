{
  "version": 3,
  "sources": ["../src/webrtc/PeerConnectionManager.ts", "../src/sidepanel.ts"],
  "sourcesContent": ["\r\nexport interface PeerConnectionConfig {\r\n    iceServers: RTCIceServer[];\r\n}\r\n\r\nexport class PeerConnectionManager {\r\n    private pc: RTCPeerConnection | null = null;\r\n    private localStream: MediaStream | null = null;\r\n    private remoteStream: MediaStream | null = null;\r\n    private config: PeerConnectionConfig = {\r\n        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\r\n    };\r\n\r\n    constructor(\r\n        private onSignal: (signal: string) => void,\r\n        private onTrack: (stream: MediaStream) => void,\r\n        private onConnectionStateChange: (state: RTCPeerConnectionState) => void,\r\n        private onError: (error: string) => void\r\n    ) { }\r\n\r\n    public async startCall(): Promise<void> {\r\n        try {\r\n            await this.initializePeerConnection();\r\n            const offer = await this.pc!.createOffer();\r\n            await this.pc!.setLocalDescription(offer);\r\n            // wait for ice gathering to complete (simplest for copy-paste)\r\n            // But actually, we need to send the offer immediately if we want to trickle?\r\n            // No, for manual copy paste, simpler to wait for ICE candidates if possible, \r\n            // OR just send the offer and handle candidates separately?\r\n            // Since we have a single text area for \"Signal\", bundling is easier.\r\n            // We'll rely on the 'icecandidate' event to update the description or just print candidates?\r\n\r\n            // Strategy: We will just dump the localDescription (which contains the SDP).\r\n            // But we need to wait for candidates to be gathered to include them in the SDP \r\n            // if we want a \"one-shot\" copy paste.\r\n            // However, for speed, let's just emit the offer. \r\n            // Browser WebRTC often requires trickling or at least waiting a bit.\r\n            // Let's implement a \"wait for gathering complete\" approach for simplicity of UX (one copy action).\r\n\r\n            if (this.pc!.iceGatheringState === 'complete') {\r\n                this.onSignal(JSON.stringify(this.pc!.localDescription));\r\n            } else {\r\n                // Wait a simplified way (or just emit what we have if user copies early)\r\n                // We will emit the offer now, and if candidates come, we might need to re-emit?\r\n                // Actually, \"localDescription\" updates as candidates are gathered? No.\r\n                // We have to wait.\r\n                this.onSignal(JSON.stringify(this.pc!.localDescription));\r\n            }\r\n\r\n        } catch (err: any) {\r\n            this.onError(`Failed to start call: ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public async joinCall(offerSdp: string): Promise<void> {\r\n        try {\r\n            await this.initializePeerConnection();\r\n            const offer = JSON.parse(offerSdp);\r\n            await this.pc!.setRemoteDescription(offer);\r\n\r\n            const answer = await this.pc!.createAnswer();\r\n            await this.pc!.setLocalDescription(answer);\r\n\r\n            // Same logic, emit answer immediately.\r\n            this.onSignal(JSON.stringify(this.pc!.localDescription));\r\n        } catch (err: any) {\r\n            console.error(err);\r\n            this.onError(`Failed to join call: ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public async connectToAnswer(answerSdp: string): Promise<void> {\r\n        if (!this.pc) return;\r\n        try {\r\n            const answer = JSON.parse(answerSdp);\r\n            await this.pc.setRemoteDescription(answer);\r\n        } catch (err: any) {\r\n            this.onError(`Failed to handle answer: ${err.message}`);\r\n        }\r\n    }\r\n\r\n    private async initializePeerConnection() {\r\n        this.cleanup();\r\n\r\n        this.pc = new RTCPeerConnection(this.config);\r\n\r\n        this.pc.onicecandidate = (event) => {\r\n            if (event.candidate) {\r\n                // We could emit candidates individually, but for simple copy-paste, \r\n                // users usually prefer one blob. \r\n                // However, `localDescription` DOES NOT automatically update with candidates in all browsers \r\n                // unless we re-fetch it? Actually in Chrome it often does or we rely on the `icecandidate` \r\n                // to trigger a \"New Signal Available\" update in UI.\r\n                // Let's just emit the Updated Local Description every time we get a candidate?\r\n                // That might spam the user. \r\n                // A common \"Manual\" pattern is to wait for 'onicecandidate' to be null (creation complete).\r\n            }\r\n            // Always emit the latest description when it changes/candidate added\r\n            if (this.pc && this.pc.localDescription) {\r\n                this.onSignal(JSON.stringify(this.pc.localDescription));\r\n            }\r\n        };\r\n\r\n        this.pc.ontrack = (event) => {\r\n            if (event.streams && event.streams[0]) {\r\n                this.remoteStream = event.streams[0];\r\n                this.onTrack(this.remoteStream);\r\n            }\r\n        };\r\n\r\n        this.pc.onconnectionstatechange = () => {\r\n            if (this.pc) {\r\n                this.onConnectionStateChange(this.pc.connectionState);\r\n            }\r\n        };\r\n\r\n        // Get Local Audio\r\n        try {\r\n            const microphonePermission = await navigator.permissions.query({name : \"microphone\"});\r\n\r\n            if(microphonePermission.state === \"denied\"){\r\n                this.onError(\"ECHO : Microphone permission denied !\")\r\n                console.error(\"ECHO ERROR : \", microphonePermission);\r\n            }\r\n            \r\n\r\n            this.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\r\n            this.localStream.getTracks().forEach(track => {\r\n                this.pc!.addTrack(track, this.localStream!);\r\n            });\r\n        } catch (err: any) {\r\n            this.onError(`Microphone access failed: ${err.message}`);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public toggleMic(enabled: boolean) {\r\n        if (this.localStream) {\r\n            this.localStream.getAudioTracks().forEach(track => {\r\n                track.enabled = enabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    public cleanup() {\r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(t => t.stop());\r\n            this.localStream = null;\r\n        }\r\n        if (this.pc) {\r\n            this.pc.close();\r\n            this.pc = null;\r\n        }\r\n        this.remoteStream = null;\r\n    }\r\n}\r\n", "\r\nimport { PeerConnectionManager } from './webrtc/PeerConnectionManager';\r\n\r\n// UI Elements\r\nconst startBtn = document.getElementById('start-call-btn') as HTMLButtonElement;\r\nconst joinBtn = document.getElementById('join-call-btn') as HTMLButtonElement;\r\nconst connectBtn = document.getElementById('connect-btn') as HTMLButtonElement;\r\nconst copySignalBtn = document.getElementById('copy-signal-btn') as HTMLButtonElement;\r\nconst endCallBtn = document.getElementById('end-call-btn') as HTMLButtonElement;\r\nconst toggleMicBtn = document.getElementById('toggle-mic-btn') as HTMLButtonElement;\r\n\r\nconst signalingArea = document.getElementById('signaling-area') as HTMLDivElement;\r\nconst callPanel = document.getElementById('call-panel') as HTMLDivElement;\r\nconst setupPanel = document.getElementById('setup-panel') as HTMLDivElement;\r\nconst localSignalArea = document.getElementById('local-signal') as HTMLTextAreaElement;\r\nconst remoteSignalArea = document.getElementById('remote-signal') as HTMLTextAreaElement;\r\nconst statusEl = document.getElementById('connection-status') as HTMLSpanElement;\r\nconst usersList = document.getElementById('connected-users-list') as HTMLDivElement;\r\n\r\nlet pcm: PeerConnectionManager | null = null;\r\nlet isMicOn = true;\r\n\r\n// Initialize PeerConnectionManager\r\nfunction initPCM() {\r\n    if (pcm) return;\r\n\r\n    pcm = new PeerConnectionManager(\r\n        (signal) => {\r\n            localSignalArea.value = signal;\r\n        },\r\n        (stream) => {\r\n            console.log('Got remote stream', stream);\r\n            // In a side panel, we can play audio directly.\r\n            const audio = new Audio();\r\n            audio.srcObject = stream;\r\n            audio.play().catch(e => console.error('Error playing audio', e));\r\n\r\n            updateUserList(true);\r\n        },\r\n        (state) => {\r\n            statusEl.innerText = state;\r\n            if (state === 'connected') {\r\n                showCallPanel();\r\n            } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {\r\n                showSetupPanel();\r\n                updateUserList(false);\r\n            }\r\n        },\r\n        (error: string) => {\r\n            console.error(error);\r\n            if (error.includes('Permission dismissed') || error.includes('Permission denied') || error.includes('Microphone permission denied')) {\r\n                // Show a manual permission button\r\n                statusEl.innerHTML = `\r\n                    Microphone access needed. \r\n                    <button id=\"grant-perm-btn\" style=\"background:#0e639c;color:white;border:none;padding:5px;cursor:pointer;\">\r\n                        Grant Permission\r\n                    </button>\r\n                `;\r\n                document.getElementById('grant-perm-btn')?.addEventListener('click', () => {\r\n                    chrome.tabs.create({ url: chrome.runtime.getURL('dist/permissions.html') });\r\n                });\r\n            } else {\r\n                alert('Error: ' + error);\r\n            }\r\n        }\r\n    );\r\n}\r\n\r\n// Event Listeners\r\nstartBtn.addEventListener('click', async () => {\r\n    initPCM();\r\n    signalingArea.classList.remove('hidden');\r\n    await pcm?.startCall();\r\n    statusEl.innerText = \"Generating Offer...\";\r\n});\r\n\r\njoinBtn.addEventListener('click', async () => {\r\n    initPCM();\r\n    signalingArea.classList.remove('hidden');\r\n    statusEl.innerText = \"Waiting for Offer...\";\r\n});\r\n\r\nconnectBtn.addEventListener('click', async () => {\r\n    const remoteSignal = remoteSignalArea.value.trim();\r\n    if (!remoteSignal) return alert('Please paste the remote signal first.');\r\n\r\n    // Determine if we are joining (have no local signal yet) or answering (already have local signal)\r\n    // Actually, \"Join\" flow: user clicks Join -> Pastes Offer -> Connect -> Generates Answer\r\n    // \"Start\" flow: User clicks Start -> Generates Offer -> Waiting -> Pastes Answer -> Connect\r\n\r\n    // Simple heuristic: If we have a local signal already, we are likely the \"Starter\" processing an Answer.\r\n    // If we don't, we are the \"Joiner\" processing an Offer.\r\n\r\n    const isStarter = localSignalArea.value.length > 0;\r\n\r\n    if (isStarter) {\r\n        // We are processing an Answer\r\n        await pcm?.connectToAnswer(remoteSignal);\r\n    } else {\r\n        // We are processing an Offer\r\n        await pcm?.joinCall(remoteSignal);\r\n    }\r\n});\r\n\r\ncopySignalBtn.addEventListener('click', () => {\r\n    localSignalArea.select();\r\n    document.execCommand('copy');\r\n    copySignalBtn.innerText = 'Copied!';\r\n    setTimeout(() => copySignalBtn.innerText = 'Copy', 2000);\r\n});\r\n\r\nendCallBtn.addEventListener('click', () => {\r\n    pcm?.cleanup();\r\n    pcm = null;\r\n    showSetupPanel();\r\n    localSignalArea.value = '';\r\n    remoteSignalArea.value = '';\r\n    updateUserList(false);\r\n    statusEl.innerText = 'Disconnected';\r\n});\r\n\r\ntoggleMicBtn.addEventListener('click', () => {\r\n    isMicOn = !isMicOn;\r\n    pcm?.toggleMic(isMicOn);\r\n    toggleMicBtn.innerText = isMicOn ? '\uD83C\uDFA4 On' : '\uD83C\uDFA4 Off';\r\n    toggleMicBtn.classList.toggle('active', isMicOn);\r\n});\r\n\r\n// UI Helpers\r\nfunction showCallPanel() {\r\n    setupPanel.classList.add('hidden');\r\n    callPanel.classList.remove('hidden');\r\n}\r\n\r\nfunction showSetupPanel() {\r\n    callPanel.classList.add('hidden');\r\n    setupPanel.classList.remove('hidden');\r\n    signalingArea.classList.add('hidden');\r\n}\r\n\r\nfunction updateUserList(connected: boolean) {\r\n    if (!connected) {\r\n        usersList.innerHTML = '';\r\n        return;\r\n    }\r\n    // Simple single peer display\r\n    usersList.innerHTML = `\r\n        <div class=\"user-item\">\r\n            <span class=\"user-icon\">\uD83D\uDC64</span>\r\n            <span class=\"user-name\">Remote User</span>\r\n            <span class=\"status-dot online\"></span>\r\n        </div>\r\n    `;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}

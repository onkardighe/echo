
import { PeerConnectionManager } from './webrtc/PeerConnectionManager';
import { SignalingClient } from './services/SignalingClient';

// UI Elements
const startBtn = document.getElementById('start-call-btn') as HTMLButtonElement;
const joinBtn = document.getElementById('join-call-btn') as HTMLButtonElement;
const connectBtn = document.getElementById('connect-btn') as HTMLButtonElement; // Reused for "Join Room"
const localSignalArea = document.getElementById('local-signal') as HTMLTextAreaElement; // Reusing for Room ID Display
const remoteSignalArea = document.getElementById('remote-signal') as HTMLTextAreaElement; // Reusing for Room ID Input
const signalingArea = document.getElementById('signaling-area') as HTMLDivElement;

const endCallBtn = document.getElementById('end-call-btn') as HTMLButtonElement;
const toggleMicBtn = document.getElementById('toggle-mic-btn') as HTMLButtonElement;

const callPanel = document.getElementById('call-panel') as HTMLDivElement;
const setupPanel = document.getElementById('setup-panel') as HTMLDivElement;
const statusEl = document.getElementById('connection-status') as HTMLSpanElement;
const usersList = document.getElementById('connected-users-list') as HTMLDivElement;

const copySignalBtn = document.getElementById('copy-signal-btn') as HTMLButtonElement; // Modify to Copy Room ID

let pcm: PeerConnectionManager | null = null;
let signalingClient: SignalingClient = new SignalingClient();
let isMicOn = true;
let currentRoomId: string | null = null;
let pollInterval: any = null;
let currentMetadataType: 'host' | 'guest' | null = null;

// Clean up UI for Room ID usage
localSignalArea.placeholder = "Room ID will appear here...";
localSignalArea.readOnly = true;
remoteSignalArea.placeholder = "Enter Room ID to join...";
copySignalBtn.innerText = "Copy Room ID";

// Initialize PeerConnectionManager
function initPCM() {
    if (pcm) return;

    pcm = new PeerConnectionManager(
        async (desc) => {
            // On Local Description (Offer or Answer)
            if (!currentRoomId) return;
            try {
                if (desc.type === 'offer') {
                    await signalingClient.sendOffer(currentRoomId, desc);
                    statusEl.innerText = "Offer sent! Waiting for guest...";
                    startPollingForAnswer();
                } else if (desc.type === 'answer') {
                    await signalingClient.sendAnswer(currentRoomId, desc);
                    statusEl.innerText = "Answer sent! Connecting...";
                }
            } catch (err) {
                console.error("Signaling Error:", err);
                statusEl.innerText = "Signaling failed.";
            }
        },
        async (candidate) => {
            // On Local ICE Candidate
            if (!currentRoomId || !currentMetadataType) return;
            // Host sends 'offer' type candidates (candidates meant for the offerer? No, candidates generated BY offerer)
            // Actually, in my server logic: 
            // addCandidate(roomId, candidate, type) -> type is WHO generated it.
            // Host generated -> type 'offer'
            // Guest generated -> type 'answer'
            const type = currentMetadataType === 'host' ? 'offer' : 'answer';
            try {
                await signalingClient.sendIceCandidate(currentRoomId, candidate, type);
            } catch (e) {
                console.warn("Failed to send candidate", e);
            }
        },
        (stream) => {
            console.log('Got remote stream', stream);
            const audio = new Audio();
            audio.srcObject = stream;
            audio.play().catch(e => console.error('Error playing audio', e));
            updateUserList(true);
        },
        (state) => {
            statusEl.innerText = state;
            if (state === 'connected') {
                showCallPanel();
                stopPolling();
            } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                endCall();
            }
        },
        (error: string) => {
            console.error(error);
            alert('Error: ' + error);
        }
    );
}

function requestMicrophonePermission(): Promise<boolean> {
    return new Promise(async (resolve) => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(t => t.stop());
            resolve(true);
        } catch (err) {
            console.warn("Mic not granted yet");
            chrome.tabs.create({ url: chrome.runtime.getURL("dist/permissions.html") });
            resolve(false);
        }
    });
}

// Polling Logic
function startPollingForAnswer() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(async () => {
        if (!currentRoomId) return;
        try {
            const answer = await signalingClient.getAnswer(currentRoomId);
            if (answer && pcm) {
                await pcm.connectToAnswer(answer);
                statusEl.innerText = "Answer received! Connecting...";
                stopPolling(); // Stop polling for answer, start polling for candidates? 
                // We should poll for candidates continuously until connected or simplified 
                startPollingForCandidates('answer'); // Host looks for 'answer' candidates
            }
        } catch (e) {
            console.warn("Polling answer error", e);
        }
    }, 2000);
}

function startPollingForCandidates(targetType: 'offer' | 'answer') {
    // If we already have an interval for answer, we cleared it. 
    // Now we poll candidates.
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(async () => {
        if (!currentRoomId || !pcm) return;
        try {
            const candidates = await signalingClient.getIceCandidates(currentRoomId);
            // Server returns ALL candidates. We filter for the ones matching targetType.
            for (const c of candidates) {
                if (c.type === targetType) {
                    // Start adding them
                    await pcm.addRemoteCandidate(c.candidate);
                }
            }
        } catch (e) {
            console.warn("Polling candidates error", e);
        }
    }, 2000);
}

function stopPolling() {
    if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
    }
}


// Event Listeners
startBtn.addEventListener('click', async () => {
    const granted = await requestMicrophonePermission();
    if (!granted) return;

    try {
        statusEl.innerText = "Creating Room...";
        currentRoomId = await signalingClient.createRoom();
        currentMetadataType = 'host';

        localSignalArea.value = currentRoomId;
        signalingArea.classList.remove('hidden');

        // Hide join-related inputs to clean UI
        remoteSignalArea.classList.add('hidden');
        connectBtn.classList.add('hidden');
        localSignalArea.classList.remove('hidden');
        copySignalBtn.classList.remove('hidden');

        initPCM();
        await pcm?.startCall(); // This will trigger onLocalDescription -> sendOffer -> poll answer

        // Also start polling for Guest's candidates immediately? 
        // No, need answer first usually, but trickle ICE can happen anytime. 
        // Let's wait for answer first in `startPollingForAnswer`.

    } catch (e) {
        statusEl.innerText = "Failed to start.";
        console.error(e);
    }
});

joinBtn.addEventListener('click', async () => {
    const granted = await requestMicrophonePermission();
    if (!granted) return;

    // Show Input UI
    signalingArea.classList.remove('hidden');
    localSignalArea.classList.add('hidden');
    copySignalBtn.classList.add('hidden');
    remoteSignalArea.classList.remove('hidden');
    connectBtn.classList.remove('hidden');
    connectBtn.innerText = "Join Room";

    statusEl.innerText = "Enter Room ID and click Join";
});

connectBtn.addEventListener('click', async () => {
    const roomId = remoteSignalArea.value.trim();
    if (!roomId) return alert('Please enter a Room ID.');

    currentRoomId = roomId;
    currentMetadataType = 'guest';

    try {
        statusEl.innerText = "Looking for room...";
        const offer = await signalingClient.getOffer(currentRoomId);

        statusEl.innerText = "Joining...";
        initPCM();
        await pcm?.joinCall(offer); // Triggers onLocalDescription -> sendAnswer

        // Start polling for Host's candidates
        startPollingForCandidates('offer');

    } catch (e) {
        alert("Failed to join room. Check ID or try again.");
        console.error(e);
        statusEl.innerText = "Join Failed";
    }
});

copySignalBtn.addEventListener('click', async () => {
    localSignalArea.select();
    await navigator.clipboard.writeText(localSignalArea.value);
    copySignalBtn.innerText = 'Copied!';
    setTimeout(() => copySignalBtn.innerText = 'Copy Room ID', 2000);
});

function endCall() {
    stopPolling();
    pcm?.cleanup();
    pcm = null;
    currentRoomId = null;
    currentMetadataType = null;
    showSetupPanel();
    localSignalArea.value = '';
    remoteSignalArea.value = '';
    updateUserList(false);
    statusEl.innerText = 'Disconnected';

    // Reset UI visibility
    remoteSignalArea.classList.remove('hidden');
    localSignalArea.classList.remove('hidden');
    connectBtn.classList.remove('hidden');
    copySignalBtn.classList.remove('hidden');
}

endCallBtn.addEventListener('click', endCall);

toggleMicBtn.addEventListener('click', () => {
    isMicOn = !isMicOn;
    pcm?.toggleMic(isMicOn);
    toggleMicBtn.innerText = isMicOn ? 'ðŸŽ¤ On' : 'ðŸŽ¤ Off';
    toggleMicBtn.classList.toggle('active', isMicOn);
});

// UI Helpers
function showCallPanel() {
    setupPanel.classList.add('hidden');
    callPanel.classList.remove('hidden');
}

function showSetupPanel() {
    callPanel.classList.add('hidden');
    setupPanel.classList.remove('hidden');
    signalingArea.classList.add('hidden');
}

function updateUserList(connected: boolean) {
    if (!connected) {
        usersList.innerHTML = '';
        return;
    }
    usersList.innerHTML = `
        <div class="user-item">
            <span class="user-icon">ðŸ‘¤</span>
            <span class="user-name">Remote User</span>
            <span class="status-dot online"></span>
        </div>
    `;
}
